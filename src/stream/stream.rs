use crate::internal::bits::log2;
use crate::internal::io_vec::IOVec;
use crate::stream::{Stream, StreamFactory};
use serde::{de::DeserializeOwned, Serialize};
use std::marker::PhantomData;
use std::vec::Vec;

/// Key/value storage on a byte stream.
///
/// `Stream` is a [`BuildingBlock`](trait.BuildingBlock.html)
/// implementation storing key/value pairs together in a byte stream.
/// The byte stream of a `Stream` can be any kind of byte stream
/// implementing the trait
/// [`Stream`](stream/trait.Stream.html) such as a
/// [file](stream/struct.FileStream.html) or a
/// [vector](stream/struct.VecStream.html).
///
/// The `Stream` building block behaves similarly as the
/// [`Array`](struct.Array.html) building block implementation.
/// In fact key/value pairs are stored in a set of vectors abstraction
/// implemented over a byte stream.
///
/// Key/value pairs of this building block are serialized/deserialized
/// into bytes inside a buffer. For a given kay/value pair, the size of
/// the corresponding buffer is the closest power of two fitting the
/// serialized pair. Given a chunk size, the chunk is stored in a vector
/// (or byte stream) of chunks of the same size.
///
/// Byte stream are generated from a structure implementing the trait
/// [`StreamFactory`](stream/trait.StreamFactory.html), such as
/// [`VecStreamFactory`](stream/struct.VecStreamFactory.html).
///
/// # Examples
///
/// ```
/// use byoc::BuildingBlock;
/// use byoc::Stream;
/// use byoc::stream::VecStreamFactory;
///
/// // Array with 3 elements capacity.
/// let mut c = Stream::new(VecStreamFactory{}, 3);
///
/// // BuildingBlock as room for 3 elements and returns an empty vector.
/// // No element is rejected.
/// assert!(c.push(vec![(1, 4), (2, 2), (3, 3)]).pop().is_none());
///
/// // Stream is full and pops extra inserted value (all values here).
/// let (key, _) = c.push(vec![(4, 12)]).pop().unwrap();
/// assert_eq!(key, 4);
///
/// // Stream pops elements in order of the highest values.
/// let (key, value) = c.pop(1).pop().unwrap();
/// assert_eq!(key, 1);
/// let (key, value) = c.pop(1).pop().unwrap();
/// assert_eq!(key, 3);
/// let (key, value) = c.pop(1).pop().unwrap();
/// assert_eq!(key, 2);
/// ```
pub struct ByteStream<'a, T, S, F>
where
    T: DeserializeOwned + Serialize,
    S: Stream<'a>,
    F: StreamFactory<S>,
{
    pub(super) factory: F,
    pub(super) stream: Vec<Option<IOVec<T, S>>>,
    pub(super) capacity: usize,
    pub(super) unused: PhantomData<&'a S>,
}

impl<'a, T, S, F> ByteStream<'a, T, S, F>
where
    T: DeserializeOwned + Serialize,
    S: Stream<'a>,
    F: StreamFactory<S>,
{
    /// Create a new `Stream` building block with a set `capacity`.
    /// Key/value pairs of this building block will be stored on byte
    /// stream generated by a
    /// [`factory`](stream/trait.StreamFactory.html).
    pub fn new(factory: F, capacity: usize) -> Self {
        let max_stream = 8 * std::mem::size_of::<usize>();
        let mut stream =
            Vec::<Option<IOVec<T, S>>>::with_capacity(max_stream);
        for _ in 0..max_stream {
            stream.push(None)
        }

        ByteStream {
            factory,
            stream,
            capacity,
            unused: PhantomData,
        }
    }

    /// Returns the position of the most significant byte
    /// starting from the left and associated power of two.
    /// The power of two is the size of the chunk that will hold the
    /// serialized value of the `size` provided as input.
    pub(super) fn chunk_size(size: usize) -> (usize, usize) {
        let i = log2(size as u64) + 1;
        let i = std::mem::size_of::<usize>() * 8 - i as usize;
        (i, 1usize + (!0usize >> i))
    }
}
