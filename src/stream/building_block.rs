use super::ByteStream;
use crate::internal::kmin::KMin;
use crate::stream::{IOVec, StreamFactory};
use crate::BuildingBlock;
use serde::{de::DeserializeOwned, Serialize};

impl<'a, K, V, F> BuildingBlock<'a, K, V> for ByteStream<(K, V), F>
where
    K: 'a + DeserializeOwned + Serialize + Ord,
    V: 'a + DeserializeOwned + Serialize + Ord,
    F: 'a + StreamFactory,
{
    /// Get the maximum storage size of this [`BuildingBlock`].
    ///
    /// This the total size in bytes stored on streams generated by this
    /// [`ByteStream`]
    /// [`StreamFactory`](./utils/stream/trait.StreamFactory.html).
    fn capacity(&self) -> usize {
        self.capacity
    }

    /// Get the size currently occupied by elements in this [`BuildingBlock`].
    ///
    /// This is the sum of the elements serialized size, each rounded up to
    /// the next power of two of elements in the container.
    fn size(&self) -> usize {
        self.stream
            .iter()
            .map(|io_vec| {
                io_vec
                    .as_ref()
                    .map(|v| v.size().unwrap_or(0usize))
                    .unwrap_or(0usize)
            })
            .sum()
    }

    /// Check if container contains a matching key.
    ///
    /// This functions reads all internal streams one by one and stops as soon
    /// as a matching key is found.
    fn contains(&self, key: &K) -> bool {
        self.stream.iter().any(|s| {
            if let Some(s) = s {
                s.iter().any(|kv| &(kv).0 == key)
            } else {
                false
            }
        })
    }

    /// Take the matching key/value pair out of the container.
    ///
    /// This functions reads all internal streams one by one and stops as soon
    /// as a matching key is found. If the key is found it is swapped out. As
    /// a result the last element of the stream takes its position.
    fn take(&mut self, key: &K) -> Option<(K, V)> {
        // Get indexe of matching key container and matching key position.
        let container_and_position =
            self.stream.iter().enumerate().find_map(
                |(stream_index, s)| match s {
                    None => None,
                    Some(s) => {
                        s.iter().enumerate().find_map(|(key_index, kv)| {
                            if &(kv).0 == key {
                                Some((stream_index, key_index))
                            } else {
                                None
                            }
                        })
                    }
                },
            );

        match container_and_position {
            None => None,
            Some((stream_index, key_index)) => {
                match self.stream[stream_index]
                    .as_mut()
                    .unwrap()
                    .swap_remove(key_index)
                {
                    Err(_) => panic!(),
                    Ok(None) => panic!(),
                    Ok(Some(v)) => Some(v),
                }
            }
        }
    }

    /// Take multiple keys out of a container at once.
    ///
    /// This functions sorts input `keys` and then reads all internal streams
    /// one by one to find matching keys. Everytime a matching key is found,
    /// it is removed from the input `keys`. The function stops when all the
    /// `keys` have been found and removed or when all the internal streams have
    /// been read.
    fn take_multiple(&mut self, keys: &mut Vec<K>) -> Vec<(K, V)> {
        let mut ret = Vec::with_capacity(keys.len());
        keys.sort();
        for stream in self.stream.iter_mut().filter_map(|s| s.as_ref()) {
            for (k, v) in stream.iter().map(|x| x.unwrap()) {
                if let Ok(i) = keys.binary_search(&k) {
                    ret.push((k, v));
                    keys.remove(i);
                    if keys.is_empty() {
                        break;
                    }
                }
            }
        }
        ret
    }

    /// Free up to `size` space from the container.
    ///
    /// This function streams the container key/values pairs in an ordered set
    /// to find the minimum set for which the sum of values is at least `size`.
    /// Once the maximum values have been found in the first pass, a second pass
    /// is executed to remove the victims from the container and return them.
    ///
    /// The memory footprint of the method is roughly the input `size` and the
    /// time complexity is `k*log(n)` where `k` is the container size and `n` is
    /// the number of elements that can fit in `size`. The IO writes are limited
    /// to the removal of victims and the IO reads are limited to the reading of
    /// all elements once.
    fn pop(&mut self, n: usize) -> Vec<(K, V)> {
        let mut set = KMin::new(n);

        // Stream values and save only the top n ones with their index.
        for (i, s) in self.stream.iter().enumerate() {
            if let Some(s) = s.as_ref() {
                let size = s.chunk_size;
                for (j, kv) in s.iter().enumerate() {
                    set.push((kv.unwrap().1, i, j), size);
                }
            }
        }

        // Filter values to only keep index and sort index.
        let mut indexes: Vec<(usize, usize)> =
            set.into_iter().map(|((_, i, j), _)| (i, j)).collect();
        indexes.sort_unstable();

        let mut ret = Vec::with_capacity(indexes.len());
        // Removes keys with swap remove from the end.
        // Position of other matching elements is not impacted
        // by the swap.
        for (i, j) in indexes.into_iter().rev() {
            match self.stream[i].as_mut().unwrap().swap_remove(j) {
                Err(_) => return ret,
                Ok(None) => return ret,
                Ok(Some(kv)) => ret.push(kv),
            }
        }
        ret
    }

    /// Insert key/value pairs in the container.
    ///
    /// This method does not check for duplicate keys. A same key can be
    /// inserted multiple times. If the container cannot
    /// store all the values, then the last input values not fitting are
    /// returned.
    fn push(&mut self, values: Vec<(K, V)>) -> Vec<(K, V)> {
        let mut out = Vec::<(K, V)>::with_capacity(values.len());
        let mut total_size = self.size();

        for value in values.into_iter() {
            let size = match bincode::serialized_size(&value) {
                Err(_) => {
                    out.push(value);
                    continue;
                }
                Ok(s) => s as usize,
            };

            let (i, chunk_size) = Self::chunk_size(size);
            if chunk_size + total_size > self.capacity {
                out.push(value);
                continue;
            }

            if self.stream[i].is_none() {
                let store = self.factory.create();
                self.stream[i] = Some(IOVec::new(store, chunk_size));
            }

            let mut value = vec![value];
            match self.stream[i].as_mut().unwrap().append(&mut value) {
                Ok(_) => total_size += chunk_size,
                Err(_) => out.push(value.pop().unwrap()),
            }
        }
        out
    }

    #[allow(clippy::needless_collect)]
    // Collect is needed to take everything out of the container.
    /// Empty the container and retrieve all of its elements.
    ///
    /// The container will create new empty streams for it self to empty itself.
    /// The old streams are made into iterators and chained together. When the
    /// returned iterator is dropped, the underlying streams are destroyed.
    fn flush(&mut self) -> Box<dyn Iterator<Item = (K, V)> + 'a> {
        let stream: Vec<IOVec<(K, V), F::Stream>> = self
            .stream
            .iter_mut()
            .filter_map(|opt| opt.take())
            .collect();
        Box::new(stream.into_iter().flat_map(|v| v.into_iter()))
    }
}

#[cfg(test)]
mod tests {
    use super::ByteStream;
    use crate::stream::VecStreamFactory;
    use crate::tests::test_building_block;

    #[test]
    fn building_block() {
        for i in [0usize, 10usize, 100usize] {
            test_building_block(
                ByteStream::new(VecStreamFactory {}, i),
                true,
            );
        }
    }
}
